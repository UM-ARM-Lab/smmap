#include "smmap/diminishing_rigidity_model.h"

#include <cmath>
#include <limits>
#include <stdexcept>
#include <algorithm>
#include <functional>
#include <Eigen/SVD>

#include <ros/ros.h>

using namespace smmap;

////////////////////////////////////////////////////////////////////////////////
// Static member initialization
////////////////////////////////////////////////////////////////////////////////

/// TODO: remove this magic number for the noise generated by this distribution
std::normal_distribution< double > DiminishingRigidityModel::perturbation_distribution_ =
    std::normal_distribution< double >( 0, 0.1 );

std::atomic_bool DiminishingRigidityModel::static_data_initialized_( false );
Eigen::MatrixXd DiminishingRigidityModel::object_initial_node_distance_;
long DiminishingRigidityModel::num_nodes_;

////////////////////////////////////////////////////////////////////////////////
// Static helpers
////////////////////////////////////////////////////////////////////////////////

/**
 * @brief DiminishingRigidityModel::SetInitialObjectConfiguration This function
 *          is not thread safe.
 * @param object_initial_configuration
 */
void DiminishingRigidityModel::SetInitialObjectConfiguration(
        const ObjectPointSet& object_initial_configuration )
{
    num_nodes_ = object_initial_configuration.cols();
    object_initial_node_distance_ = CalculateDistanceMatrix( object_initial_configuration );
    static_data_initialized_.store( true );
}

////////////////////////////////////////////////////////////////////////////////
// Constructors and Destructor
////////////////////////////////////////////////////////////////////////////////

DiminishingRigidityModel::DiminishingRigidityModel( double deformability )
    : DiminishingRigidityModel( deformability, deformability )
{}

DiminishingRigidityModel::DiminishingRigidityModel(
        double translation_deformability,
        double rotation_deformability )
    : translation_deformability_( translation_deformability )
    , rotation_deformability_( rotation_deformability )
{
    if ( !static_data_initialized_.load() )
    {
        throw new std::runtime_error(
                    "You must call SetInitialObjectConfiguration before constructing a DiminishingRigidityModel" );
    }

    if ( translation_deformability < 0 )
    {
        throw new std::invalid_argument( "translation_deformability must be >= 0" );
    }
    if ( rotation_deformability < 0 )
    {
        throw new std::invalid_argument( "rotation_deformability must be >= 0" );
    }
}

////////////////////////////////////////////////////////////////////////////////
// Virtual function overrides
////////////////////////////////////////////////////////////////////////////////

void DiminishingRigidityModel::updateModel( const std::vector<WorldState>& feedback )
{
    // This model doesn't do any updates, so tell the compiler that it's okay
    // that these values are unused.
    (void)feedback;
}

void DiminishingRigidityModel::perturbModel( std::mt19937_64& generator )
{
    translation_deformability_ += perturbation_distribution_( generator );
    rotation_deformability_ += perturbation_distribution_( generator );

    if ( translation_deformability_ < 0 )
    {
        translation_deformability_ = 0;
    }
    if ( rotation_deformability_ < 0 )
    {
        rotation_deformability_ = 0;
    }
}

////////////////////////////////////////////////////////////////////////////////
// Helper used only by AdaptiveJacobian (at the moment)
// Find a better way to do this
////////////////////////////////////////////////////////////////////////////////

Eigen::MatrixXd DiminishingRigidityModel::getGrippersToObjectJacobian(
        const AllGrippersSinglePose& grippers_pose,
        const ObjectPointSet& current_configuration ) const
{
    return computeGrippersToObjectJacobian( grippers_pose, current_configuration );
}

////////////////////////////////////////////////////////////////////////////////
// Computation helpers
////////////////////////////////////////////////////////////////////////////////

/**
 * @brief DiminishingRigidityModel::computeObjectToGripperJacobian
 * Computes a Jacobian that converts gripper velocities in the individual
 * gripper frames into object velocities in the world frame
 * @param grippers_data
 */
Eigen::MatrixXd DiminishingRigidityModel::computeGrippersToObjectJacobian(
        const AllGrippersSinglePose& grippers_pose,
        const ObjectPointSet& current_configuration ) const
{
    //ROS_DEBUG_NAMED( "diminishing_rigidity_model" , "Computing object Jacobian: Diminishing rigidity k_trans: %f k_rot: %f", translation_deformablity_, rotation_deformability_ );

    const long num_grippers = (long)grippers_pose.size();
    const long num_Jcols = num_grippers * 6;
    const long num_Jrows = num_nodes_ * 3;

    Eigen::MatrixXd J( num_Jrows, num_Jcols );

    // for each gripper
    for ( long gripper_ind = 0; gripper_ind < num_grippers; gripper_ind++ )
    {
        // Get all the data we need for a given gripper
        const Eigen::Matrix3d& gripper_rot = grippers_pose[(size_t)gripper_ind].rotation();

        for ( long node_ind = 0; node_ind < num_nodes_; node_ind++ )
        {
            // TODO: do I need to use the gripper_node_index that is returned by this function?
            const std::pair< long, double > dist_to_gripper
                = getMinimumDistanceToGripper( grippers_data_[(size_t)gripper_ind].node_indices,
                        node_ind, object_initial_node_distance_ );

            const Eigen::Matrix3d& J_trans = gripper_rot;

            J.block< 3, 3 >( node_ind * 3, gripper_ind * 6 ) =
                    std::exp( -translation_deformability_ * dist_to_gripper.second ) * J_trans;

            Eigen::Matrix3d J_rot;

            // Vector from gripper to node
            const Eigen::Vector3d gripper_to_node =
                    current_configuration.block< 3, 1 >( 0, node_ind ) -
                    grippers_pose[(size_t)gripper_ind].translation();

            J_rot.block< 3, 1 >( 0, 0 ) = gripper_rot.block< 3, 1 >( 0, 0 ).cross( gripper_to_node );
            J_rot.block< 3, 1 >( 0, 1 ) = gripper_rot.block< 3, 1 >( 0, 1 ).cross( gripper_to_node );
            J_rot.block< 3, 1 >( 0, 2 ) = gripper_rot.block< 3, 1 >( 0, 2 ).cross( gripper_to_node );

            J.block< 3, 3 >( node_ind * 3, gripper_ind * 6 + 3 ) =
                    std::exp( -rotation_deformability_ * dist_to_gripper.second ) * J_rot;
        }
    }

    return J;
}
